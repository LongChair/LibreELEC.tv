diff --git a/qtbase/src/gui/configure.json b/qtbase/src/gui/configure.json
index dab66fafb4..27e913877f 100644
--- a/qtbase/src/gui/configure.json
+++ b/qtbase/src/gui/configure.json
@@ -1,7 +1,8 @@
 {
     "module": "gui",
     "depends": [
-        "core"
+        "core",
+        "network"
     ],
     "testDir": "../../config.tests",
 
@@ -201,7 +202,7 @@
             "test": {
                 "include": "harfbuzz/hb.h",
                 "tail": [
-                    "#if !HB_VERSION_ATLEAST(0, 9, 42)",
+                    "#if !HB_VERSION_ATLEAST(1, 6, 0)",
                     "#  error This version of harfbuzz is too old.",
                     "#endif"
                 ],
@@ -390,6 +391,30 @@
                 "-lts"
             ]
         },
+        "v4l2": {
+            "label": "V4L2",
+            "test": {
+                "include": [
+                    "cstddef"
+                ],
+                "tail": [
+                    "extern \"C\" {",
+                    "#include <mediactl/mediactl.h>",
+                    "#include <mediactl/v4l2subdev.h>",
+                    "}"
+                ],
+                "main": [
+                    "v4l2_format fmt;",
+                    "media_pad *pad = nullptr;",
+                    "media_device *device = media_device_new(\"/dev/media\");",
+                    "v4l2_subdev_set_format(nullptr, nullptr, 0, V4L2_SUBDEV_FORMAT_ACTIVE);"
+                ]
+            },
+            "sources": [
+                { "type": "pkgConfig", "args": "libv4l2 libmediactl" },
+                "-lmediactl -lv4l2 -lv4l2subdev"
+            ]
+        },
         "vulkan": {
             "label": "Vulkan",
             "test": "qpa/vulkan",
@@ -956,7 +981,8 @@
         },
         "fontconfig": {
             "label": "Fontconfig",
-            "condition": "!config.win32 && !config.darwin && features.system-freetype && libs.fontconfig",
+            "autoDetect": "!config.darwin",
+            "condition": "!config.win32 && features.system-freetype && libs.fontconfig",
             "output": [ "privateFeature", "feature" ]
         },
         "gbm": {
@@ -1020,10 +1046,19 @@
             "condition": "tests.linuxfb && features.regularexpression",
             "output": [ "privateFeature" ]
         },
+        "vsp2": {
+            "label": "VSP2",
+            "condition": "libs.v4l2",
+            "autoDetect": false,
+            "output": [ "privateFeature" ]
+        },
         "vnc": {
             "label": "VNC",
             "section": "Platform plugins",
-            "condition": "config.unix && !config.android && !config.darwin && features.regularexpression",
+            "condition": [
+                "config.unix && !config.android && !config.darwin",
+                "features.regularexpression && features.network"
+            ],
             "output": [ "privateFeature" ]
         },
         "mirclient": {
@@ -1137,6 +1172,11 @@
             "condition": "features.eglfs && features.gbm && features.kms",
             "output": [ "privateFeature" ]
         },
+        "eglfs_vsp2": {
+            "label": "EGLFS VSP2",
+            "condition": "features.eglfs && features.gbm && features.kms && features.vsp2",
+            "output": [ "privateFeature" ]
+        },
         "eglfs_mali": {
             "label": "EGLFS Mali",
             "condition": "features.eglfs && (tests.egl-mali || tests.egl-mali-2)",
@@ -1227,6 +1267,12 @@
             "condition": "libs.tslib",
             "output": [ "privateFeature" ]
         },
+        "tuiotouch": {
+            "label": "TuioTouch",
+            "purpose": "Provides the TuioTouch input plugin.",
+            "condition": "features.network && features.udpsocket",
+            "output": [ "privateFeature" ]
+        },
         "xcb": {
             "label": "XCB",
             "section": "Platform plugins",
@@ -1317,6 +1363,7 @@
         },
         "xlib": {
             "label": "XLib",
+            "autoDetect": "!config.darwin || features.xcb",
             "condition": "tests.xlib",
             "output": [ "privateFeature" ]
         },
@@ -1537,6 +1584,13 @@
             "condition": "features.xcb && !features.xkbcommon-system && !features.xkb-config-root",
             "message": "Could not find XKB config root, use -xkb-config-root to set a path to
 XKB configuration data. This is required for keyboard input support."
+        },
+        {
+            "type": "note",
+            "condition": "features.xcb && config.darwin",
+            "message": "XCB support on macOS is minimal and untested. Some features will
+not work properly or at all (e.g. OpenGL, desktop services or accessibility),
+or may depend on your system and XQuartz setup."
         },
         {
             "type": "note",
@@ -1648,7 +1702,7 @@ QMAKE_LIBDIR_OPENGL[_ES2] and QMAKE_LIBS_OPENGL[_ES2] in the mkspec for your pla
                     "section": "EGLFS details",
                     "condition": "features.eglfs",
                     "entries": [
-                        "eglfs_openwfd", "eglfs_viv", "eglfs_viv_wl", "eglfs_rcar", "eglfs_egldevice", "eglfs_gbm", "eglfs_mali", "eglfs_brcm", "egl_x11"
+                        "eglfs_openwfd", "eglfs_viv", "eglfs_viv_wl", "eglfs_rcar", "eglfs_egldevice", "eglfs_gbm", "eglfs_vsp2", "eglfs_mali", "eglfs_brcm", "egl_x11"
                     ]
                 },
                 "linuxfb", "vnc", "mirclient",
diff --git a/qtbase/src/platformsupport/kmsconvenience/qkmsdevice.cpp b/qtbase/src/platformsupport/kmsconvenience/qkmsdevice.cpp
index a25a1e582f..59db3da776 100644
--- a/qtbase/src/platformsupport/kmsconvenience/qkmsdevice.cpp
+++ b/qtbase/src/platformsupport/kmsconvenience/qkmsdevice.cpp
@@ -1,6 +1,6 @@
 /****************************************************************************
 **
-** Copyright (C) 2016 The Qt Company Ltd.
+** Copyright (C) 2017 The Qt Company Ltd.
 ** Copyright (C) 2016 Pelagicore AG
 ** Copyright (C) 2015 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
 ** Contact: https://www.qt.io/licensing/
@@ -47,6 +47,8 @@
 #include <QtCore/QFile>
 #include <QtCore/QLoggingCategory>
 
+#include <errno.h>
+
 #define ARRAY_LENGTH(a) (sizeof (a) / sizeof (a)[0])
 
 QT_BEGIN_NAMESPACE
@@ -75,7 +77,7 @@ int QKmsDevice::crtcForConnector(drmModeResPtr resources, drmModeConnectorPtr co
 
         for (int j = 0; j < resources->count_crtcs; j++) {
             bool isPossible = possibleCrtcs & (1 << j);
-            bool isAvailable = !(m_crtc_allocator & 1 << resources->crtcs[j]);
+            bool isAvailable = !(m_crtc_allocator & (1 << j));
 
             if (isPossible && isAvailable)
                 return j;
@@ -162,22 +164,24 @@ static bool parseModeline(const QByteArray &text, drmModeModeInfoPtr mode)
 
 QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
                                                       drmModeConnectorPtr connector,
-                                                      VirtualDesktopInfo *vinfo)
+                                                      ScreenInfo *vinfo)
 {
+    Q_ASSERT(vinfo);
     const QByteArray connectorName = nameForConnector(connector);
 
     const int crtc = crtcForConnector(resources, connector);
     if (crtc < 0) {
         qWarning() << "No usable crtc/encoder pair for connector" << connectorName;
-        return Q_NULLPTR;
+        return nullptr;
     }
 
     OutputConfiguration configuration;
     QSize configurationSize;
+    int configurationRefresh = 0;
     drmModeModeInfo configurationModeline;
 
     auto userConfig = m_screenConfig->outputSettings();
-    auto userConnectorConfig = userConfig.value(QString::fromUtf8(connectorName));
+    QVariantMap userConnectorConfig = userConfig.value(QString::fromUtf8(connectorName));
     // default to the preferred mode unless overridden in the config
     const QByteArray mode = userConnectorConfig.value(QStringLiteral("mode"), QStringLiteral("preferred"))
         .toByteArray().toLower();
@@ -187,6 +191,10 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
         configuration = OutputConfigPreferred;
     } else if (mode == "current") {
         configuration = OutputConfigCurrent;
+    } else if (sscanf(mode.constData(), "%dx%d@%d", &configurationSize.rwidth(), &configurationSize.rheight(),
+                      &configurationRefresh) == 3)
+    {
+        configuration = OutputConfigMode;
     } else if (sscanf(mode.constData(), "%dx%d", &configurationSize.rwidth(), &configurationSize.rheight()) == 2) {
         configuration = OutputConfigMode;
     } else if (parseModeline(mode, &configurationModeline)) {
@@ -195,31 +203,30 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
         qWarning("Invalid mode \"%s\" for output %s", mode.constData(), connectorName.constData());
         configuration = OutputConfigPreferred;
     }
-    if (vinfo) {
-        *vinfo = VirtualDesktopInfo();
-        vinfo->virtualIndex = userConnectorConfig.value(QStringLiteral("virtualIndex"), INT_MAX).toInt();
-        if (userConnectorConfig.contains(QStringLiteral("virtualPos"))) {
-            const QByteArray vpos = userConnectorConfig.value(QStringLiteral("virtualPos")).toByteArray();
-            const QByteArrayList vposComp = vpos.split(',');
-            if (vposComp.count() == 2)
-                vinfo->virtualPos = QPoint(vposComp[0].trimmed().toInt(), vposComp[1].trimmed().toInt());
-        }
-        if (userConnectorConfig.value(QStringLiteral("primary")).toBool())
-            vinfo->isPrimary = true;
+
+    *vinfo = ScreenInfo();
+    vinfo->virtualIndex = userConnectorConfig.value(QStringLiteral("virtualIndex"), INT_MAX).toInt();
+    if (userConnectorConfig.contains(QStringLiteral("virtualPos"))) {
+        const QByteArray vpos = userConnectorConfig.value(QStringLiteral("virtualPos")).toByteArray();
+        const QByteArrayList vposComp = vpos.split(',');
+        if (vposComp.count() == 2)
+            vinfo->virtualPos = QPoint(vposComp[0].trimmed().toInt(), vposComp[1].trimmed().toInt());
     }
+    if (userConnectorConfig.value(QStringLiteral("primary")).toBool())
+        vinfo->isPrimary = true;
 
     const uint32_t crtc_id = resources->crtcs[crtc];
 
     if (configuration == OutputConfigOff) {
         qCDebug(qLcKmsDebug) << "Turning off output" << connectorName;
-        drmModeSetCrtc(m_dri_fd, crtc_id, 0, 0, 0, 0, 0, Q_NULLPTR);
-        return Q_NULLPTR;
+        drmModeSetCrtc(m_dri_fd, crtc_id, 0, 0, 0, 0, 0, nullptr);
+        return nullptr;
     }
 
     // Skip disconnected output
     if (configuration == OutputConfigPreferred && connector->connection == DRM_MODE_DISCONNECTED) {
         qCDebug(qLcKmsDebug) << "Skipping disconnected output" << connectorName;
-        return Q_NULLPTR;
+        return nullptr;
     }
 
     // Get the current mode on the current crtc
@@ -230,7 +237,7 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
         drmModeFreeEncoder(encoder);
 
         if (!crtc)
-            return Q_NULLPTR;
+            return nullptr;
 
         if (crtc->mode_valid)
             crtc_mode = crtc->mode;
@@ -240,7 +247,8 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
 
     QList<drmModeModeInfo> modes;
     modes.reserve(connector->count_modes);
-    qCDebug(qLcKmsDebug) << connectorName << "mode count:" << connector->count_modes;
+    qCDebug(qLcKmsDebug) << connectorName << "mode count:" << connector->count_modes
+                         << "crtc index:" << crtc << "crtc id:" << crtc_id;
     for (int i = 0; i < connector->count_modes; i++) {
         const drmModeModeInfo &mode = connector->modes[i];
         qCDebug(qLcKmsDebug) << "mode" << i << mode.hdisplay << "x" << mode.vdisplay
@@ -256,9 +264,11 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
     for (int i = modes.size() - 1; i >= 0; i--) {
         const drmModeModeInfo &m = modes.at(i);
 
-        if (configuration == OutputConfigMode &&
-                m.hdisplay == configurationSize.width() &&
-                m.vdisplay == configurationSize.height()) {
+        if (configuration == OutputConfigMode
+                && m.hdisplay == configurationSize.width()
+                && m.vdisplay == configurationSize.height()
+                && (!configurationRefresh || m.vrefresh == uint32_t(configurationRefresh)))
+        {
             configured = i;
         }
 
@@ -297,7 +307,7 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
 
     if (selected_mode < 0) {
         qWarning() << "No modes available for output" << connectorName;
-        return Q_NULLPTR;
+        return nullptr;
     } else {
         int width = modes[selected_mode].hdisplay;
         int height = modes[selected_mode].vdisplay;
@@ -324,24 +334,72 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
     }
     qCDebug(qLcKmsDebug) << "Physical size is" << physSize << "mm" << "for output" << connectorName;
 
-    QKmsOutput output = {
-        QString::fromUtf8(connectorName),
-        connector->connector_id,
-        crtc_id,
-        physSize,
-        selected_mode,
-        selected_mode,
-        false,
-        drmModeGetCrtc(m_dri_fd, crtc_id),
-        modes,
-        connector->subpixel,
-        connectorProperty(connector, QByteArrayLiteral("DPMS")),
-        connectorPropertyBlob(connector, QByteArrayLiteral("EDID")),
-        false,
-        0,
-        false
-    };
+    const QByteArray formatStr = userConnectorConfig.value(QStringLiteral("format"), QStringLiteral("xrgb8888"))
+            .toByteArray().toLower();
+    uint32_t drmFormat;
+    if (formatStr == "xrgb8888") {
+        drmFormat = DRM_FORMAT_XRGB8888;
+    } else if (formatStr == "xbgr8888") {
+        drmFormat = DRM_FORMAT_XBGR8888;
+    } else if (formatStr == "argb8888") {
+        drmFormat = DRM_FORMAT_ARGB8888;
+    } else if (formatStr == "abgr8888") {
+        drmFormat = DRM_FORMAT_ABGR8888;
+    } else if (formatStr == "rgb565") {
+        drmFormat = DRM_FORMAT_RGB565;
+    } else if (formatStr == "bgr565") {
+        drmFormat = DRM_FORMAT_BGR565;
+    } else if (formatStr == "xrgb2101010") {
+        drmFormat = DRM_FORMAT_XRGB2101010;
+    } else if (formatStr == "xbgr2101010") {
+        drmFormat = DRM_FORMAT_XBGR2101010;
+    } else if (formatStr == "argb2101010") {
+        drmFormat = DRM_FORMAT_ARGB2101010;
+    } else if (formatStr == "abgr2101010") {
+        drmFormat = DRM_FORMAT_ABGR2101010;
+    } else {
+        qWarning("Invalid pixel format \"%s\" for output %s", formatStr.constData(), connectorName.constData());
+        drmFormat = DRM_FORMAT_XRGB8888;
+    }
+
+    const QString cloneSource = userConnectorConfig.value(QStringLiteral("clones")).toString();
+    if (!cloneSource.isEmpty())
+        qCDebug(qLcKmsDebug) << "Output" << connectorName << " clones output " << cloneSource;
+
+    QKmsOutput output;
+    output.name = QString::fromUtf8(connectorName);
+    output.connector_id = connector->connector_id;
+    output.crtc_index = crtc;
+    output.crtc_id = crtc_id;
+    output.physical_size = physSize;
+    output.preferred_mode = preferred >= 0 ? preferred : selected_mode;
+    output.mode = selected_mode;
+    output.mode_set = false;
+    output.saved_crtc = drmModeGetCrtc(m_dri_fd, crtc_id);
+    output.modes = modes;
+    output.subpixel = connector->subpixel;
+    output.dpms_prop = connectorProperty(connector, QByteArrayLiteral("DPMS"));
+    output.edid_blob = connectorPropertyBlob(connector, QByteArrayLiteral("EDID"));
+    output.wants_forced_plane = false;
+    output.forced_plane_id = 0;
+    output.forced_plane_set = false;
+    output.drm_format = drmFormat;
+    output.clone_source = cloneSource;
+
+    QString planeListStr;
+    for (const QKmsPlane &plane : qAsConst(m_planes)) {
+        if (plane.possibleCrtcs & (1 << output.crtc_index)) {
+            output.available_planes.append(plane);
+            planeListStr.append(QString::number(plane.id));
+            planeListStr.append(QLatin1Char(' '));
+        }
+    }
+    qCDebug(qLcKmsDebug, "Output %s can use %d planes: %s",
+            connectorName.constData(), output.available_planes.count(), qPrintable(planeListStr));
 
+    // This is for the EGLDevice/EGLStream backend. On some of those devices one
+    // may want to target a pre-configured plane. It is probably useless for
+    // eglfs_kms and others. Do not confuse with generic plane support (available_planes).
     bool ok;
     int idx = qEnvironmentVariableIntValue("QT_QPA_EGLFS_KMS_PLANE_INDEX", &ok);
     if (ok) {
@@ -350,8 +408,8 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
             if (idx >= 0 && idx < int(planeResources->count_planes)) {
                 drmModePlane *plane = drmModeGetPlane(m_dri_fd, planeResources->planes[idx]);
                 if (plane) {
-                    output.wants_plane = true;
-                    output.plane_id = plane->plane_id;
+                    output.wants_forced_plane = true;
+                    output.forced_plane_id = plane->plane_id;
                     qCDebug(qLcKmsDebug, "Forcing plane index %d, plane id %u (belongs to crtc id %u)",
                             idx, plane->plane_id, plane->crtc_id);
                     drmModeFreePlane(plane);
@@ -362,8 +420,9 @@ QPlatformScreen *QKmsDevice::createScreenForConnector(drmModeResPtr resources,
         }
     }
 
-    m_crtc_allocator |= (1 << output.crtc_id);
-    m_connector_allocator |= (1 << output.connector_id);
+    m_crtc_allocator |= (1 << output.crtc_index);
+
+    vinfo->output = output;
 
     return createScreen(output);
 }
@@ -381,7 +440,7 @@ drmModePropertyPtr QKmsDevice::connectorProperty(drmModeConnectorPtr connector,
         drmModeFreeProperty(prop);
     }
 
-    return Q_NULLPTR;
+    return nullptr;
 }
 
 drmModePropertyBlobPtr QKmsDevice::connectorPropertyBlob(drmModeConnectorPtr connector, const QByteArray &name)
@@ -406,7 +465,6 @@ QKmsDevice::QKmsDevice(QKmsScreenConfig *screenConfig, const QString &path)
     , m_path(path)
     , m_dri_fd(-1)
     , m_crtc_allocator(0)
-    , m_connector_allocator(0)
 {
     if (m_path.isEmpty()) {
         m_path = m_screenConfig->devicePath();
@@ -425,10 +483,10 @@ QKmsDevice::~QKmsDevice()
 struct OrderedScreen
 {
     OrderedScreen() : screen(nullptr) { }
-    OrderedScreen(QPlatformScreen *screen, const QKmsDevice::VirtualDesktopInfo &vinfo)
+    OrderedScreen(QPlatformScreen *screen, const QKmsDevice::ScreenInfo &vinfo)
         : screen(screen), vinfo(vinfo) { }
     QPlatformScreen *screen;
-    QKmsDevice::VirtualDesktopInfo vinfo;
+    QKmsDevice::ScreenInfo vinfo;
 };
 
 QDebug operator<<(QDebug dbg, const OrderedScreen &s)
@@ -449,12 +507,29 @@ static bool orderedScreenLessThan(const OrderedScreen &a, const OrderedScreen &b
 
 void QKmsDevice::createScreens()
 {
+    // Headless mode using a render node: cannot do any output related DRM
+    // stuff. Skip it all and register a dummy screen.
+    if (m_screenConfig->headless()) {
+        QPlatformScreen *screen = createHeadlessScreen();
+        if (screen) {
+            qCDebug(qLcKmsDebug, "Headless mode enabled");
+            registerScreen(screen, true, QPoint(0, 0), QList<QPlatformScreen *>());
+            return;
+        } else {
+            qWarning("QKmsDevice: Requested headless mode without support in the backend. Request is ignored.");
+        }
+    }
+
+    drmSetClientCap(m_dri_fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+
     drmModeResPtr resources = drmModeGetResources(m_dri_fd);
     if (!resources) {
-        qWarning("drmModeGetResources failed");
+        qErrnoWarning(errno, "drmModeGetResources failed");
         return;
     }
 
+    discoverPlanes();
+
     QVector<OrderedScreen> screens;
 
     int wantedConnectorIndex = -1;
@@ -475,7 +550,7 @@ void QKmsDevice::createScreens()
         if (!connector)
             continue;
 
-        VirtualDesktopInfo vinfo;
+        ScreenInfo vinfo;
         QPlatformScreen *screen = createScreenForConnector(resources, connector, &vinfo);
         if (screen)
             screens.append(OrderedScreen(screen, vinfo));
@@ -490,6 +565,32 @@ void QKmsDevice::createScreens()
     std::stable_sort(screens.begin(), screens.end(), orderedScreenLessThan);
     qCDebug(qLcKmsDebug) << "Sorted screen list:" << screens;
 
+    // The final list of screens is available, so do the second phase setup.
+    // Hook up clone sources and targets.
+    for (const OrderedScreen &orderedScreen : screens) {
+        QVector<QPlatformScreen *> screensCloningThisScreen;
+        for (const OrderedScreen &s : screens) {
+            if (s.vinfo.output.clone_source == orderedScreen.vinfo.output.name)
+                screensCloningThisScreen.append(s.screen);
+        }
+        QPlatformScreen *screenThisScreenClones = nullptr;
+        if (!orderedScreen.vinfo.output.clone_source.isEmpty()) {
+            for (const OrderedScreen &s : screens) {
+                if (s.vinfo.output.name == orderedScreen.vinfo.output.clone_source) {
+                    screenThisScreenClones = s.screen;
+                    break;
+                }
+            }
+        }
+        if (screenThisScreenClones)
+            qCDebug(qLcKmsDebug) << orderedScreen.screen->name() << "clones" << screenThisScreenClones;
+        if (!screensCloningThisScreen.isEmpty())
+            qCDebug(qLcKmsDebug) << orderedScreen.screen->name() << "is cloned by" << screensCloningThisScreen;
+
+        registerScreenCloning(orderedScreen.screen, screenThisScreenClones, screensCloningThisScreen);
+    }
+
+    // Figure out the virtual desktop and register the screens to QPA/QGuiApplication.
     QPoint pos(0, 0);
     QList<QPlatformScreen *> siblings;
     QVector<QPoint> virtualPositions;
@@ -531,6 +632,132 @@ void QKmsDevice::createScreens()
     }
 }
 
+QPlatformScreen *QKmsDevice::createHeadlessScreen()
+{
+    // headless mode not supported by default
+    return nullptr;
+}
+
+// not all subclasses support screen cloning
+void QKmsDevice::registerScreenCloning(QPlatformScreen *screen,
+                                       QPlatformScreen *screenThisScreenClones,
+                                       const QVector<QPlatformScreen *> &screensCloningThisScreen)
+{
+    Q_UNUSED(screen);
+    Q_UNUSED(screenThisScreenClones);
+    Q_UNUSED(screensCloningThisScreen);
+}
+
+// drm_property_type_is is not available in old headers
+static inline bool propTypeIs(drmModePropertyPtr prop, uint32_t type)
+{
+    if (prop->flags & DRM_MODE_PROP_EXTENDED_TYPE)
+        return (prop->flags & DRM_MODE_PROP_EXTENDED_TYPE) == type;
+    return prop->flags & type;
+}
+
+void QKmsDevice::enumerateProperties(drmModeObjectPropertiesPtr objProps, PropCallback callback)
+{
+    for (uint32_t propIdx = 0; propIdx < objProps->count_props; ++propIdx) {
+        drmModePropertyPtr prop = drmModeGetProperty(m_dri_fd, objProps->props[propIdx]);
+        if (!prop)
+            continue;
+
+        const quint64 value = objProps->prop_values[propIdx];
+        qCDebug(qLcKmsDebug, "  property %d: id = %u name = '%s'", propIdx, prop->prop_id, prop->name);
+
+        if (propTypeIs(prop, DRM_MODE_PROP_SIGNED_RANGE)) {
+            qCDebug(qLcKmsDebug, "  type is SIGNED_RANGE, value is %lld, possible values are:", qint64(value));
+            for (int i = 0; i < prop->count_values; ++i)
+                qCDebug(qLcKmsDebug, "    %lld", qint64(prop->values[i]));
+        } else if (propTypeIs(prop, DRM_MODE_PROP_RANGE)) {
+            qCDebug(qLcKmsDebug, "  type is RANGE, value is %llu, possible values are:", value);
+            for (int i = 0; i < prop->count_values; ++i)
+                qCDebug(qLcKmsDebug, "    %llu", quint64(prop->values[i]));
+        } else if (propTypeIs(prop, DRM_MODE_PROP_ENUM)) {
+            qCDebug(qLcKmsDebug, "  type is ENUM, value is %llu, possible values are:", value);
+            for (int i = 0; i < prop->count_enums; ++i)
+                qCDebug(qLcKmsDebug, "    enum %d: %s - %llu", i, prop->enums[i].name, prop->enums[i].value);
+        } else if (propTypeIs(prop, DRM_MODE_PROP_BITMASK)) {
+            qCDebug(qLcKmsDebug, "  type is BITMASK, value is %llu, possible bits are:", value);
+            for (int i = 0; i < prop->count_enums; ++i)
+                qCDebug(qLcKmsDebug, "    bitmask %d: %s - %u", i, prop->enums[i].name, 1 << prop->enums[i].value);
+        } else if (propTypeIs(prop, DRM_MODE_PROP_BLOB)) {
+            qCDebug(qLcKmsDebug, "  type is BLOB");
+        } else if (propTypeIs(prop, DRM_MODE_PROP_OBJECT)) {
+            qCDebug(qLcKmsDebug, "  type is OBJECT");
+        }
+
+        callback(prop, value);
+
+        drmModeFreeProperty(prop);
+    }
+}
+
+void QKmsDevice::discoverPlanes()
+{
+    m_planes.clear();
+
+    drmModePlaneResPtr planeResources = drmModeGetPlaneResources(m_dri_fd);
+    if (!planeResources)
+        return;
+
+    const int countPlanes = planeResources->count_planes;
+    qCDebug(qLcKmsDebug, "Found %d planes", countPlanes);
+    for (int planeIdx = 0; planeIdx < countPlanes; ++planeIdx) {
+        drmModePlanePtr drmplane = drmModeGetPlane(m_dri_fd, planeResources->planes[planeIdx]);
+        if (!drmplane) {
+            qCDebug(qLcKmsDebug, "Failed to query plane %d, ignoring", planeIdx);
+            continue;
+        }
+
+        QKmsPlane plane;
+        plane.id = drmplane->plane_id;
+        plane.possibleCrtcs = drmplane->possible_crtcs;
+
+        const int countFormats = drmplane->count_formats;
+        QString formatStr;
+        for (int i = 0; i < countFormats; ++i) {
+            uint32_t f = drmplane->formats[i];
+            plane.supportedFormats.append(f);
+            QString s;
+            s.sprintf("%c%c%c%c ", f, f >> 8, f >> 16, f >> 24);
+            formatStr += s;
+        }
+
+        qCDebug(qLcKmsDebug, "plane %d: id = %u countFormats = %d possibleCrtcs = 0x%x supported formats = %s",
+                planeIdx, plane.id, countFormats, plane.possibleCrtcs, qPrintable(formatStr));
+
+        drmModeFreePlane(drmplane);
+
+        drmModeObjectPropertiesPtr objProps = drmModeObjectGetProperties(m_dri_fd, plane.id, DRM_MODE_OBJECT_PLANE);
+        if (!objProps) {
+            qCDebug(qLcKmsDebug, "Failed to query plane %d object properties, ignoring", planeIdx);
+            continue;
+        }
+
+        enumerateProperties(objProps, [&plane](drmModePropertyPtr prop, quint64 value) {
+            if (!strcmp(prop->name, "type")) {
+                plane.type = QKmsPlane::Type(value);
+            } else if (!strcmp(prop->name, "rotation")) {
+                plane.initialRotation = QKmsPlane::Rotations(int(value));
+                plane.availableRotations = 0;
+                if (propTypeIs(prop, DRM_MODE_PROP_BITMASK)) {
+                    for (int i = 0; i < prop->count_enums; ++i)
+                        plane.availableRotations |= QKmsPlane::Rotation(1 << prop->enums[i].value);
+                }
+                plane.rotationPropertyId = prop->prop_id;
+            }
+        });
+
+        m_planes.append(plane);
+
+        drmModeFreeObjectProperties(objProps);
+    }
+
+    drmModeFreePlaneResources(planeResources);
+}
+
 int QKmsDevice::fd() const
 {
     return m_dri_fd;
@@ -552,7 +779,8 @@ QKmsScreenConfig *QKmsDevice::screenConfig() const
 }
 
 QKmsScreenConfig::QKmsScreenConfig()
-    : m_hwCursor(true)
+    : m_headless(false)
+    , m_hwCursor(true)
     , m_separateScreens(false)
     , m_pbuffers(false)
     , m_virtualDesktopLayout(VirtualDesktopLayoutHorizontal)
@@ -587,6 +815,16 @@ void QKmsScreenConfig::loadConfig()
 
     const QJsonObject object = doc.object();
 
+    const QString headlessStr = object.value(QLatin1String("headless")).toString();
+    const QByteArray headless = headlessStr.toUtf8();
+    QSize headlessSize;
+    if (sscanf(headless.constData(), "%dx%d", &headlessSize.rwidth(), &headlessSize.rheight()) == 2) {
+        m_headless = true;
+        m_headlessSize = headlessSize;
+    } else {
+        m_headless = false;
+    }
+
     m_hwCursor = object.value(QLatin1String("hwcursor")).toBool(m_hwCursor);
     m_pbuffers = object.value(QLatin1String("pbuffers")).toBool(m_pbuffers);
     m_devicePath = object.value(QLatin1String("device")).toString();
@@ -618,6 +856,7 @@ void QKmsScreenConfig::loadConfig()
     }
 
     qCDebug(qLcKmsDebug) << "Requested configuration (some settings may be ignored):\n"
+                         << "\theadless:" << m_headless << "\n"
                          << "\thwcursor:" << m_hwCursor << "\n"
                          << "\tpbuffers:" << m_pbuffers << "\n"
                          << "\tseparateScreens:" << m_separateScreens << "\n"
diff --git a/qtbase/src/platformsupport/kmsconvenience/qkmsdevice_p.h b/qtbase/src/platformsupport/kmsconvenience/qkmsdevice_p.h
index 964a0b1775..5eecedec39 100644
--- a/qtbase/src/platformsupport/kmsconvenience/qkmsdevice_p.h
+++ b/qtbase/src/platformsupport/kmsconvenience/qkmsdevice_p.h
@@ -59,6 +59,42 @@
 
 #include <xf86drm.h>
 #include <xf86drmMode.h>
+#include <drm_fourcc.h>
+
+#include <functional>
+
+// In less fortunate cases one may need to build on a system with dev headers
+// from the dark ages. Let's pull a GL and define the missing stuff outselves.
+
+#ifndef DRM_PLANE_TYPE_OVERLAY
+#define DRM_PLANE_TYPE_OVERLAY 0
+#endif
+#ifndef DRM_PLANE_TYPE_PRIMARY
+#define DRM_PLANE_TYPE_PRIMARY 1
+#endif
+#ifndef DRM_PLANE_TYPE_CURSOR
+#define DRM_PLANE_TYPE_CURSOR 2
+#endif
+
+#ifndef DRM_CLIENT_CAP_UNIVERSAL_PLANES
+#define DRM_CLIENT_CAP_UNIVERSAL_PLANES 2
+#endif
+#ifndef DRM_CLIENT_CAP_ATOMIC
+#define DRM_CLIENT_CAP_ATOMIC 3
+#endif
+
+#ifndef DRM_MODE_PROP_EXTENDED_TYPE
+#define DRM_MODE_PROP_EXTENDED_TYPE 0x0000ffc0
+#endif
+#ifndef DRM_MODE_PROP_TYPE
+#define DRM_MODE_PROP_TYPE(n) ((n) << 6)
+#endif
+#ifndef DRM_MODE_PROP_OBJECT
+#define DRM_MODE_PROP_OBJECT DRM_MODE_PROP_TYPE(1)
+#endif
+#ifndef DRM_MODE_PROP_SIGNED_RANGE
+#define DRM_MODE_PROP_SIGNED_RANGE DRM_MODE_PROP_TYPE(2)
+#endif
 
 QT_BEGIN_NAMESPACE
 
@@ -76,6 +112,8 @@ public:
 
     QString devicePath() const { return m_devicePath; }
 
+    bool headless() const { return m_headless; }
+    QSize headlessSize() const { return m_headlessSize; }
     bool hwCursor() const { return m_hwCursor; }
     bool separateScreens() const { return m_separateScreens; }
     bool supportsPBuffers() const { return m_pbuffers; }
@@ -87,6 +125,8 @@ private:
     void loadConfig();
 
     QString m_devicePath;
+    bool m_headless;
+    QSize m_headlessSize;
     bool m_hwCursor;
     bool m_separateScreens;
     bool m_pbuffers;
@@ -94,23 +134,63 @@ private:
     QMap<QString, QVariantMap> m_outputSettings;
 };
 
+// NB! QKmsPlane does not store the current state and offers no functions to
+// change object properties. Any such functionality belongs to subclasses since
+// in some cases atomic operations will be desired where a mere
+// drmModeObjectSetProperty would not be acceptable.
+struct QKmsPlane
+{
+    enum Type {
+        OverlayPlane = DRM_PLANE_TYPE_OVERLAY,
+        PrimaryPlane = DRM_PLANE_TYPE_PRIMARY,
+        CursorPlane = DRM_PLANE_TYPE_CURSOR
+    };
+
+    enum Rotation {
+        Rotation0 = 1 << 0,
+        Rotation90 = 1 << 1,
+        Rotation180 = 1 << 2,
+        Rotation270 = 1 << 3,
+        RotationReflectX = 1 << 4,
+        RotationReflectY = 1 << 5
+    };
+    Q_DECLARE_FLAGS(Rotations, Rotation)
+
+    uint32_t id = 0;
+    Type type = OverlayPlane;
+
+    int possibleCrtcs = 0;
+
+    QVector<uint32_t> supportedFormats;
+
+    Rotations initialRotation = Rotation0;
+    Rotations availableRotations = Rotation0;
+    uint32_t rotationPropertyId = 0;
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QKmsPlane::Rotations)
+
 struct QKmsOutput
 {
     QString name;
-    uint32_t connector_id;
-    uint32_t crtc_id;
+    uint32_t connector_id = 0;
+    uint32_t crtc_index = 0;
+    uint32_t crtc_id = 0;
     QSizeF physical_size;
-    int preferred_mode; // index of preferred mode in list below
-    int mode; // index of selected mode in list below
-    bool mode_set;
-    drmModeCrtcPtr saved_crtc;
+    int preferred_mode = -1; // index of preferred mode in list below
+    int mode = -1; // index of selected mode in list below
+    bool mode_set = false;
+    drmModeCrtcPtr saved_crtc = nullptr;
     QList<drmModeModeInfo> modes;
-    int subpixel;
-    drmModePropertyPtr dpms_prop;
-    drmModePropertyBlobPtr edid_blob;
-    bool wants_plane;
-    uint32_t plane_id;
-    bool plane_set;
+    int subpixel = DRM_MODE_SUBPIXEL_UNKNOWN;
+    drmModePropertyPtr dpms_prop = nullptr;
+    drmModePropertyBlobPtr edid_blob = nullptr;
+    bool wants_forced_plane = false;
+    uint32_t forced_plane_id = 0;
+    bool forced_plane_set = false;
+    uint32_t drm_format = DRM_FORMAT_XRGB8888;
+    QString clone_source;
+    QVector<QKmsPlane> available_planes;
 
     void restoreMode(QKmsDevice *device);
     void cleanup(QKmsDevice *device);
@@ -121,11 +201,11 @@ struct QKmsOutput
 class QKmsDevice
 {
 public:
-    struct VirtualDesktopInfo {
-    VirtualDesktopInfo() : virtualIndex(0), isPrimary(false) { }
-        int virtualIndex;
+    struct ScreenInfo {
+        int virtualIndex = 0;
         QPoint virtualPos;
-        bool isPrimary;
+        bool isPrimary = false;
+        QKmsOutput output;
     };
 
     QKmsDevice(QKmsScreenConfig *screenConfig, const QString &path = QString());
@@ -144,6 +224,10 @@ public:
 
 protected:
     virtual QPlatformScreen *createScreen(const QKmsOutput &output) = 0;
+    virtual QPlatformScreen *createHeadlessScreen();
+    virtual void registerScreenCloning(QPlatformScreen *screen,
+                                       QPlatformScreen *screenThisScreenClones,
+                                       const QVector<QPlatformScreen *> &screensCloningThisScreen);
     virtual void registerScreen(QPlatformScreen *screen,
                                 bool isPrimary,
                                 const QPoint &virtualPos,
@@ -153,16 +237,20 @@ protected:
     int crtcForConnector(drmModeResPtr resources, drmModeConnectorPtr connector);
     QPlatformScreen *createScreenForConnector(drmModeResPtr resources,
                                               drmModeConnectorPtr connector,
-                                              VirtualDesktopInfo *vinfo);
+                                              ScreenInfo *vinfo);
     drmModePropertyPtr connectorProperty(drmModeConnectorPtr connector, const QByteArray &name);
     drmModePropertyBlobPtr connectorPropertyBlob(drmModeConnectorPtr connector, const QByteArray &name);
+    typedef std::function<void(drmModePropertyPtr, quint64)> PropCallback;
+    void enumerateProperties(drmModeObjectPropertiesPtr objProps, PropCallback callback);
+    void discoverPlanes();
 
     QKmsScreenConfig *m_screenConfig;
     QString m_path;
     int m_dri_fd;
 
     quint32 m_crtc_allocator;
-    quint32 m_connector_allocator;
+
+    QVector<QKmsPlane> m_planes;
 
 private:
     Q_DISABLE_COPY(QKmsDevice)
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
index 87fb3146c7..4742143121 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.cpp
@@ -1,7 +1,7 @@
 /****************************************************************************
 **
+** Copyright (C) 2017 The Qt Company Ltd.
 ** Copyright (C) 2015 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
-** Copyright (C) 2016 The Qt Company Ltd.
 ** Copyright (C) 2016 Pelagicore AG
 ** Contact: https://www.qt.io/licensing/
 **
@@ -55,6 +55,18 @@ QT_BEGIN_NAMESPACE
 
 Q_DECLARE_LOGGING_CATEGORY(qLcEglfsKmsDebug)
 
+static inline uint32_t drmFormatToGbmFormat(uint32_t drmFormat)
+{
+    Q_ASSERT(DRM_FORMAT_XRGB8888 == GBM_FORMAT_XRGB8888);
+    return drmFormat;
+}
+
+static inline uint32_t gbmFormatToDrmFormat(uint32_t gbmFormat)
+{
+    Q_ASSERT(DRM_FORMAT_XRGB8888 == GBM_FORMAT_XRGB8888);
+    return gbmFormat;
+}
+
 void QEglFSKmsGbmScreen::bufferDestroyedHandler(gbm_bo *bo, void *data)
 {
     FrameBuffer *fb = static_cast<FrameBuffer *>(data);
@@ -77,29 +89,34 @@ QEglFSKmsGbmScreen::FrameBuffer *QEglFSKmsGbmScreen::framebufferForBufferObject(
 
     uint32_t width = gbm_bo_get_width(bo);
     uint32_t height = gbm_bo_get_height(bo);
-    uint32_t stride = gbm_bo_get_stride(bo);
-    uint32_t handle = gbm_bo_get_handle(bo).u32;
+    uint32_t handles[4] = { gbm_bo_get_handle(bo).u32 };
+    uint32_t strides[4] = { gbm_bo_get_stride(bo) };
+    uint32_t offsets[4] = { 0 };
+    uint32_t pixelFormat = gbmFormatToDrmFormat(gbm_bo_get_format(bo));
 
     QScopedPointer<FrameBuffer> fb(new FrameBuffer);
+    qCDebug(qLcEglfsKmsDebug, "Adding FB, size %ux%u, DRM format 0x%x", width, height, pixelFormat);
 
-    int ret = drmModeAddFB(device()->fd(), width, height, 24, 32,
-                           stride, handle, &fb->fb);
+    int ret = drmModeAddFB2(device()->fd(), width, height, pixelFormat,
+                            handles, strides, offsets, &fb->fb, 0);
 
     if (ret) {
         qWarning("Failed to create KMS FB!");
-        return Q_NULLPTR;
+        return nullptr;
     }
 
     gbm_bo_set_user_data(bo, fb.data(), bufferDestroyedHandler);
     return fb.take();
 }
 
-QEglFSKmsGbmScreen::QEglFSKmsGbmScreen(QKmsDevice *device, const QKmsOutput &output)
-    : QEglFSKmsScreen(device, output)
-    , m_gbm_surface(Q_NULLPTR)
-    , m_gbm_bo_current(Q_NULLPTR)
-    , m_gbm_bo_next(Q_NULLPTR)
-    , m_cursor(Q_NULLPTR)
+QEglFSKmsGbmScreen::QEglFSKmsGbmScreen(QKmsDevice *device, const QKmsOutput &output, bool headless)
+    : QEglFSKmsScreen(device, output, headless)
+    , m_gbm_surface(nullptr)
+    , m_gbm_bo_current(nullptr)
+    , m_gbm_bo_next(nullptr)
+    , m_flipPending(false)
+    , m_cursor(nullptr)
+    , m_cloneSource(nullptr)
 {
 }
 
@@ -114,6 +131,8 @@ QEglFSKmsGbmScreen::~QEglFSKmsGbmScreen()
 QPlatformCursor *QEglFSKmsGbmScreen::cursor() const
 {
     QKmsScreenConfig *config = device()->screenConfig();
+    if (config->headless())
+        return nullptr;
     if (config->hwCursor()) {
         if (!config->separateScreens())
             return static_cast<QEglFSKmsGbmDevice *>(device())->globalCursor();
@@ -132,47 +151,112 @@ QPlatformCursor *QEglFSKmsGbmScreen::cursor() const
 gbm_surface *QEglFSKmsGbmScreen::createSurface()
 {
     if (!m_gbm_surface) {
-        qCDebug(qLcEglfsKmsDebug) << "Creating window for screen" << name();
+        uint32_t gbmFormat = drmFormatToGbmFormat(m_output.drm_format);
+        qCDebug(qLcEglfsKmsDebug, "Creating gbm_surface for screen %s with format 0x%x", qPrintable(name()), gbmFormat);
         m_gbm_surface = gbm_surface_create(static_cast<QEglFSKmsGbmDevice *>(device())->gbmDevice(),
                                            rawGeometry().width(),
                                            rawGeometry().height(),
-                                           GBM_FORMAT_XRGB8888,
+                                           gbmFormat,
                                            GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);
     }
-    return m_gbm_surface;
+    return m_gbm_surface; // not owned, gets destroyed in QEglFSKmsGbmIntegration::destroyNativeWindow() via QEglFSKmsGbmWindow::invalidateSurface()
 }
 
-void QEglFSKmsGbmScreen::destroySurface()
+void QEglFSKmsGbmScreen::resetSurface()
 {
-    if (m_gbm_bo_current) {
-        gbm_bo_destroy(m_gbm_bo_current);
-        m_gbm_bo_current = Q_NULLPTR;
-    }
+    m_gbm_surface = nullptr;
+}
 
-    if (m_gbm_bo_next) {
-        gbm_bo_destroy(m_gbm_bo_next);
-        m_gbm_bo_next = Q_NULLPTR;
+void QEglFSKmsGbmScreen::initCloning(QPlatformScreen *screenThisScreenClones,
+                                     const QVector<QPlatformScreen *> &screensCloningThisScreen)
+{
+    // clone destinations need to know the clone source
+    const bool clonesAnother = screenThisScreenClones != nullptr;
+    if (clonesAnother && !screensCloningThisScreen.isEmpty()) {
+        qWarning("QEglFSKmsGbmScreen %s cannot be clone source and destination at the same time", qPrintable(name()));
+        return;
     }
+    if (clonesAnother)
+        m_cloneSource = static_cast<QEglFSKmsGbmScreen *>(screenThisScreenClones);
+
+    // clone sources need to know their additional destinations
+    for (QPlatformScreen *s : screensCloningThisScreen) {
+        CloneDestination d;
+        d.screen = static_cast<QEglFSKmsGbmScreen *>(s);
+        m_cloneDests.append(d);
+    }
+}
+
+void QEglFSKmsGbmScreen::ensureModeSet(uint32_t fb)
+{
+    QKmsOutput &op(output());
+    const int fd = device()->fd();
+
+    if (!op.mode_set) {
+        op.mode_set = true;
+
+        bool doModeSet = true;
+        drmModeCrtcPtr currentMode = drmModeGetCrtc(fd, op.crtc_id);
+        const bool alreadySet = currentMode && !memcmp(&currentMode->mode, &op.modes[op.mode], sizeof(drmModeModeInfo));
+        if (currentMode)
+            drmModeFreeCrtc(currentMode);
+        if (alreadySet) {
+            static bool alwaysDoSet = qEnvironmentVariableIntValue("QT_QPA_EGLFS_ALWAYS_SET_MODE");
+            if (!alwaysDoSet) {
+                qCDebug(qLcEglfsKmsDebug, "Mode already set, skipping modesetting for screen %s", qPrintable(name()));
+                doModeSet = false;
+            }
+        }
 
-    if (m_gbm_surface) {
-        gbm_surface_destroy(m_gbm_surface);
-        m_gbm_surface = Q_NULLPTR;
+        if (doModeSet) {
+            qCDebug(qLcEglfsKmsDebug, "Setting mode for screen %s", qPrintable(name()));
+            int ret = drmModeSetCrtc(fd,
+                                     op.crtc_id,
+                                     fb,
+                                     0, 0,
+                                     &op.connector_id, 1,
+                                     &op.modes[op.mode]);
+
+            if (ret == 0)
+                setPowerState(PowerStateOn);
+            else
+                qErrnoWarning(errno, "Could not set DRM mode for screen %s", qPrintable(name()));
+        }
     }
 }
 
 void QEglFSKmsGbmScreen::waitForFlip()
 {
+    if (m_headless || m_cloneSource)
+        return;
+
     // Don't lock the mutex unless we actually need to
     if (!m_gbm_bo_next)
         return;
 
     QMutexLocker lock(&m_waitForFlipMutex);
-    while (m_gbm_bo_next)
-        static_cast<QEglFSKmsGbmDevice *>(device())->handleDrmEvent();
+    while (m_gbm_bo_next) {
+        drmEventContext drmEvent;
+        memset(&drmEvent, 0, sizeof(drmEvent));
+        drmEvent.version = 2;
+        drmEvent.vblank_handler = nullptr;
+        drmEvent.page_flip_handler = pageFlipHandler;
+        drmHandleEvent(device()->fd(), &drmEvent);
+    }
 }
 
 void QEglFSKmsGbmScreen::flip()
 {
+    // For headless screen just return silently. It is not necessarily an error
+    // to end up here, so show no warnings.
+    if (m_headless)
+        return;
+
+    if (m_cloneSource) {
+        qWarning("Screen %s clones another screen. swapBuffers() not allowed.", qPrintable(name()));
+        return;
+    }
+
     if (!m_gbm_surface) {
         qWarning("Cannot sync before platform init!");
         return;
@@ -185,60 +269,92 @@ void QEglFSKmsGbmScreen::flip()
     }
 
     FrameBuffer *fb = framebufferForBufferObject(m_gbm_bo_next);
+    ensureModeSet(fb->fb);
 
     QKmsOutput &op(output());
     const int fd = device()->fd();
-    const uint32_t w = op.modes[op.mode].hdisplay;
-    const uint32_t h = op.modes[op.mode].vdisplay;
-
-    if (!op.mode_set) {
-        int ret = drmModeSetCrtc(fd,
-                                 op.crtc_id,
-                                 fb->fb,
-                                 0, 0,
-                                 &op.connector_id, 1,
-                                 &op.modes[op.mode]);
-
-        if (ret == -1) {
-            qErrnoWarning(errno, "Could not set DRM mode!");
-        } else {
-            op.mode_set = true;
-            setPowerState(PowerStateOn);
-
-            if (!op.plane_set) {
-                op.plane_set = true;
-                if (op.wants_plane) {
-                    int ret = drmModeSetPlane(fd, op.plane_id, op.crtc_id,
-                                              uint32_t(-1), 0,
-                                              0, 0, w, h,
-                                              0 << 16, 0 << 16, w << 16, h << 16);
-                    if (ret == -1)
-                        qErrnoWarning(errno, "drmModeSetPlane failed");
-                }
-            }
-        }
-    }
-
+    m_flipPending = true;
     int ret = drmModePageFlip(fd,
                               op.crtc_id,
                               fb->fb,
                               DRM_MODE_PAGE_FLIP_EVENT,
                               this);
     if (ret) {
-        qErrnoWarning("Could not queue DRM page flip!");
+        qErrnoWarning("Could not queue DRM page flip on screen %s", qPrintable(name()));
+        m_flipPending = false;
         gbm_surface_release_buffer(m_gbm_surface, m_gbm_bo_next);
-        m_gbm_bo_next = Q_NULLPTR;
+        m_gbm_bo_next = nullptr;
+        return;
+    }
+
+    for (CloneDestination &d : m_cloneDests) {
+        if (d.screen != this) {
+            d.screen->ensureModeSet(fb->fb);
+            d.cloneFlipPending = true;
+            int ret = drmModePageFlip(fd,
+                                      d.screen->output().crtc_id,
+                                      fb->fb,
+                                      DRM_MODE_PAGE_FLIP_EVENT,
+                                      d.screen);
+            if (ret) {
+                qErrnoWarning("Could not queue DRM page flip for clone screen %s", qPrintable(name()));
+                d.cloneFlipPending = false;
+            }
+        }
     }
 }
 
+void QEglFSKmsGbmScreen::pageFlipHandler(int fd, unsigned int sequence, unsigned int tv_sec, unsigned int tv_usec, void *user_data)
+{
+    Q_UNUSED(fd);
+    Q_UNUSED(sequence);
+    Q_UNUSED(tv_sec);
+    Q_UNUSED(tv_usec);
+
+    QEglFSKmsGbmScreen *screen = static_cast<QEglFSKmsGbmScreen *>(user_data);
+    screen->flipFinished();
+}
+
 void QEglFSKmsGbmScreen::flipFinished()
 {
+    if (m_cloneSource) {
+        m_cloneSource->cloneDestFlipFinished(this);
+        return;
+    }
+
+    m_flipPending = false;
+    updateFlipStatus();
+}
+
+void QEglFSKmsGbmScreen::cloneDestFlipFinished(QEglFSKmsGbmScreen *cloneDestScreen)
+{
+    for (CloneDestination &d : m_cloneDests) {
+        if (d.screen == cloneDestScreen) {
+            d.cloneFlipPending = false;
+            break;
+        }
+    }
+    updateFlipStatus();
+}
+
+void QEglFSKmsGbmScreen::updateFlipStatus()
+{
+    Q_ASSERT(!m_cloneSource);
+
+    if (m_flipPending)
+        return;
+
+    for (const CloneDestination &d : m_cloneDests) {
+        if (d.cloneFlipPending)
+            return;
+    }
+
     if (m_gbm_bo_current)
         gbm_surface_release_buffer(m_gbm_surface,
                                    m_gbm_bo_current);
 
     m_gbm_bo_current = m_gbm_bo_next;
-    m_gbm_bo_next = Q_NULLPTR;
+    m_gbm_bo_next = nullptr;
 }
 
 QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h
index 341cc95bbe..f5a2122723 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmscreen.h
@@ -54,34 +54,54 @@ class QEglFSKmsGbmCursor;
 class QEglFSKmsGbmScreen : public QEglFSKmsScreen
 {
 public:
-    QEglFSKmsGbmScreen(QKmsDevice *device, const QKmsOutput &output);
+    QEglFSKmsGbmScreen(QKmsDevice *device, const QKmsOutput &output, bool headless);
     ~QEglFSKmsGbmScreen();
 
     QPlatformCursor *cursor() const override;
 
-    gbm_surface *surface() const { return m_gbm_surface; }
     gbm_surface *createSurface();
-    void destroySurface();
+    void resetSurface();
+
+    void initCloning(QPlatformScreen *screenThisScreenClones,
+                     const QVector<QPlatformScreen *> &screensCloningThisScreen);
 
     void waitForFlip() override;
-    void flip() override;
-    void flipFinished() override;
+
+    void flip();
 
 private:
+    void flipFinished();
+    void ensureModeSet(uint32_t fb);
+    void cloneDestFlipFinished(QEglFSKmsGbmScreen *cloneDestScreen);
+    void updateFlipStatus();
+
+    static void pageFlipHandler(int fd,
+                                unsigned int sequence,
+                                unsigned int tv_sec,
+                                unsigned int tv_usec,
+                                void *user_data);
+
     gbm_surface *m_gbm_surface;
 
     gbm_bo *m_gbm_bo_current;
     gbm_bo *m_gbm_bo_next;
+    bool m_flipPending;
 
     QScopedPointer<QEglFSKmsGbmCursor> m_cursor;
 
     struct FrameBuffer {
-        FrameBuffer() : fb(0) {}
-        uint32_t fb;
+        uint32_t fb = 0;
     };
     static void bufferDestroyedHandler(gbm_bo *bo, void *data);
     FrameBuffer *framebufferForBufferObject(gbm_bo *bo);
 
+    QEglFSKmsGbmScreen *m_cloneSource;
+    struct CloneDestination {
+        QEglFSKmsGbmScreen *screen = nullptr;
+        bool cloneFlipPending = false;
+    };
+    QVector<CloneDestination> m_cloneDests;
+
     static QMutex m_waitForFlipMutex;
 };
 
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsintegration.cpp b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsintegration.cpp
index c77151181e..06bc272050 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsintegration.cpp
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsintegration.cpp
@@ -55,7 +55,7 @@ QT_BEGIN_NAMESPACE
 Q_LOGGING_CATEGORY(qLcEglfsKmsDebug, "qt.qpa.eglfs.kms")
 
 QEglFSKmsIntegration::QEglFSKmsIntegration()
-    : m_device(Q_NULLPTR),
+    : m_device(nullptr),
       m_screenConfig(new QKmsScreenConfig)
 {
 }
@@ -78,7 +78,7 @@ void QEglFSKmsIntegration::platformDestroy()
     qCDebug(qLcEglfsKmsDebug, "platformDestroy: Closing DRM device");
     m_device->close();
     delete m_device;
-    m_device = Q_NULLPTR;
+    m_device = nullptr;
 }
 
 EGLNativeDisplayType QEglFSKmsIntegration::platformDisplay() const
@@ -133,6 +133,24 @@ bool QEglFSKmsIntegration::supportsPBuffers() const
     return m_screenConfig->supportsPBuffers();
 }
 
+void *QEglFSKmsIntegration::nativeResourceForIntegration(const QByteArray &name)
+{
+    if (name == QByteArrayLiteral("dri_fd") && m_device)
+        return (void *) (qintptr) m_device->fd();
+
+    return nullptr;
+}
+
+void *QEglFSKmsIntegration::nativeResourceForScreen(const QByteArray &resource, QScreen *screen)
+{
+    QEglFSKmsScreen *s = static_cast<QEglFSKmsScreen *>(screen->handle());
+    if (s) {
+        if (resource == QByteArrayLiteral("dri_crtcid"))
+            return (void *) (qintptr) s->output().crtc_id;
+    }
+    return nullptr;
+}
+
 QKmsDevice *QEglFSKmsIntegration::device() const
 {
     return m_device;
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsintegration.h b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsintegration.h
index 9955616919..e2c37f60fc 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsintegration.h
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsintegration.h
@@ -69,6 +69,8 @@ public:
     bool hasCapability(QPlatformIntegration::Capability cap) const override;
     void waitForVSync(QPlatformSurface *surface) const override;
     bool supportsPBuffers() const override;
+    void *nativeResourceForIntegration(const QByteArray &name) override;
+    void *nativeResourceForScreen(const QByteArray &resource, QScreen *screen) override;
 
     QKmsDevice *device() const;
     QKmsScreenConfig *screenConfig() const;
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_egldevice/qeglfskmsegldevicescreen.cpp b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_egldevice/qeglfskmsegldevicescreen.cpp
index a27c89faab..531b73d1dc 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_egldevice/qeglfskmsegldevicescreen.cpp
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_egldevice/qeglfskmsegldevicescreen.cpp
@@ -105,12 +105,12 @@ void QEglFSKmsEglDeviceScreen::waitForFlip()
             qErrnoWarning(errno, "drmModeSetCrtc failed");
     }
 
-    if (!op.plane_set) {
-        op.plane_set = true;
+    if (!op.forced_plane_set) {
+        op.forced_plane_set = true;
 
-        if (op.wants_plane) {
-            qCDebug(qLcEglfsKmsDebug, "Setting plane %u", op.plane_id);
-            int ret = drmModeSetPlane(fd, op.plane_id, op.crtc_id, uint32_t(-1), 0,
+        if (op.wants_forced_plane) {
+            qCDebug(qLcEglfsKmsDebug, "Setting plane %u", op.forced_plane_id);
+            int ret = drmModeSetPlane(fd, op.forced_plane_id, op.crtc_id, uint32_t(-1), 0,
                                       0, 0, w, h,
                                       0 << 16, 0 << 16, w << 16, h << 16);
             if (ret == -1)
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsscreen.cpp b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsscreen.cpp
index 734f5cd611..5e45b42abe 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsscreen.cpp
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsscreen.cpp
@@ -1,7 +1,7 @@
 /****************************************************************************
 **
+** Copyright (C) 2017 The Qt Company Ltd.
 ** Copyright (C) 2017 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
-** Copyright (C) 2016 The Qt Company Ltd.
 ** Copyright (C) 2016 Pelagicore AG
 ** Contact: https://www.qt.io/licensing/
 **
@@ -68,12 +68,13 @@ private:
     QEglFSKmsScreen *m_screen;
 };
 
-QEglFSKmsScreen::QEglFSKmsScreen(QKmsDevice *device, const QKmsOutput &output)
+QEglFSKmsScreen::QEglFSKmsScreen(QKmsDevice *device, const QKmsOutput &output, bool headless)
     : QEglFSScreen(static_cast<QEglFSIntegration *>(QGuiApplicationPrivate::platformIntegration())->display())
     , m_device(device)
     , m_output(output)
     , m_powerState(PowerStateOn)
     , m_interruptHandler(new QEglFSKmsInterruptHandler(this))
+    , m_headless(headless)
 {
     m_siblings << this; // gets overridden later
 
@@ -109,6 +110,9 @@ void QEglFSKmsScreen::setVirtualPosition(const QPoint &pos)
 // geometry() calls rawGeometry() and may apply additional transforms.
 QRect QEglFSKmsScreen::rawGeometry() const
 {
+    if (m_headless)
+        return QRect(QPoint(0, 0), m_device->screenConfig()->headlessSize());
+
     const int mode = m_output.mode;
     return QRect(m_pos.x(), m_pos.y(),
                  m_output.modes[mode].hdisplay,
@@ -117,12 +121,30 @@ QRect QEglFSKmsScreen::rawGeometry() const
 
 int QEglFSKmsScreen::depth() const
 {
-    return 32;
+    return format() == QImage::Format_RGB16 ? 16 : 32;
 }
 
 QImage::Format QEglFSKmsScreen::format() const
 {
-    return QImage::Format_RGB32;
+    // the result can be slightly incorrect, it won't matter in practice
+    switch (m_output.drm_format) {
+    case DRM_FORMAT_ARGB8888:
+    case DRM_FORMAT_ABGR8888:
+        return QImage::Format_ARGB32;
+    case DRM_FORMAT_RGB565:
+    case DRM_FORMAT_BGR565:
+        return QImage::Format_RGB16;
+    case DRM_FORMAT_XRGB2101010:
+        return QImage::Format_RGB30;
+    case DRM_FORMAT_XBGR2101010:
+        return QImage::Format_BGR30;
+    case DRM_FORMAT_ARGB2101010:
+        return QImage::Format_A2RGB30_Premultiplied;
+    case DRM_FORMAT_ABGR2101010:
+        return QImage::Format_A2BGR30_Premultiplied;
+    default:
+        return QImage::Format_RGB32;
+    }
 }
 
 QSizeF QEglFSKmsScreen::physicalSize() const
@@ -159,7 +181,7 @@ Qt::ScreenOrientation QEglFSKmsScreen::orientation() const
 
 QString QEglFSKmsScreen::name() const
 {
-    return m_output.name;
+    return !m_headless ? m_output.name : QStringLiteral("qt_Headless");
 }
 
 QString QEglFSKmsScreen::manufacturer() const
@@ -177,22 +199,10 @@ QString QEglFSKmsScreen::serialNumber() const
     return m_edid.serialNumber;
 }
 
-void QEglFSKmsScreen::destroySurface()
-{
-}
-
 void QEglFSKmsScreen::waitForFlip()
 {
 }
 
-void QEglFSKmsScreen::flip()
-{
-}
-
-void QEglFSKmsScreen::flipFinished()
-{
-}
-
 void QEglFSKmsScreen::restoreMode()
 {
     m_output.restoreMode(m_device);
@@ -200,6 +210,9 @@ void QEglFSKmsScreen::restoreMode()
 
 qreal QEglFSKmsScreen::refreshRate() const
 {
+    if (m_headless)
+        return 60;
+
     quint32 refresh = m_output.modes[m_output.mode].vrefresh;
     return refresh > 0 ? refresh : 60;
 }
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsscreen.h b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsscreen.h
index 4e09929189..7f395aacb7 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsscreen.h
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_support/qeglfskmsscreen.h
@@ -56,7 +56,7 @@ class QEglFSKmsInterruptHandler;
 class Q_EGLFS_EXPORT QEglFSKmsScreen : public QEglFSScreen
 {
 public:
-    QEglFSKmsScreen(QKmsDevice *device, const QKmsOutput &output);
+    QEglFSKmsScreen(QKmsDevice *device, const QKmsOutput &output, bool headless = false);
     ~QEglFSKmsScreen();
 
     void setVirtualPosition(const QPoint &pos);
@@ -89,11 +89,7 @@ public:
 
     QKmsDevice *device() const { return m_device; }
 
-    void destroySurface();
-
     virtual void waitForFlip();
-    virtual void flip();
-    virtual void flipFinished();
 
     QKmsOutput &output() { return m_output; }
     void restoreMode();
@@ -115,6 +111,8 @@ protected:
     PowerState m_powerState;
 
     QEglFSKmsInterruptHandler *m_interruptHandler;
+
+    bool m_headless;
 };
 
 QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp b/qtbase/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp
index e411ea55e9..1b8f50a1c6 100644
--- a/qtbase/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp
+++ b/qtbase/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration.cpp
@@ -103,7 +103,7 @@ QStringList QEglFSDeviceIntegrationFactory::keys(const QString &pluginPath)
 
 QEglFSDeviceIntegration *QEglFSDeviceIntegrationFactory::create(const QString &key, const QString &pluginPath)
 {
-    QEglFSDeviceIntegration *integration = Q_NULLPTR;
+    QEglFSDeviceIntegration *integration = nullptr;
 #if QT_CONFIG(library)
     if (!pluginPath.isEmpty()) {
         QCoreApplication::addLibraryPath(pluginPath);
@@ -351,9 +351,28 @@ bool QEglFSDeviceIntegration::supportsSurfacelessContexts() const
     return true;
 }
 
+QFunctionPointer QEglFSDeviceIntegration::platformFunction(const QByteArray &function) const
+{
+    Q_UNUSED(function);
+    return nullptr;
+}
+
+void *QEglFSDeviceIntegration::nativeResourceForIntegration(const QByteArray &name)
+{
+    Q_UNUSED(name);
+    return nullptr;
+}
+
+void *QEglFSDeviceIntegration::nativeResourceForScreen(const QByteArray &resource, QScreen *screen)
+{
+    Q_UNUSED(resource);
+    Q_UNUSED(screen);
+    return nullptr;
+}
+
 void *QEglFSDeviceIntegration::wlDisplay() const
 {
-    return Q_NULLPTR;
+    return nullptr;
 }
 
 EGLConfig QEglFSDeviceIntegration::chooseConfig(EGLDisplay display, const QSurfaceFormat &format)
diff --git a/qtbase/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h b/qtbase/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h
index 4335554912..71ffb4c69a 100644
--- a/qtbase/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h
+++ b/qtbase/src/plugins/platforms/eglfs/api/qeglfsdeviceintegration_p.h
@@ -103,7 +103,9 @@ public:
     virtual int framebufferIndex() const;
     virtual bool supportsPBuffers() const;
     virtual bool supportsSurfacelessContexts() const;
-
+    virtual QFunctionPointer platformFunction(const QByteArray &function) const;
+    virtual void *nativeResourceForIntegration(const QByteArray &name);
+    virtual void *nativeResourceForScreen(const QByteArray &resource, QScreen *screen);
     virtual void *wlDisplay() const;
 
     static EGLConfig chooseConfig(EGLDisplay display, const QSurfaceFormat &format);
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp
index e218d580a2..20127ae7f7 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.cpp
@@ -53,28 +53,17 @@ QT_BEGIN_NAMESPACE
 
 Q_DECLARE_LOGGING_CATEGORY(qLcEglfsKmsDebug)
 
-void QEglFSKmsGbmDevice::pageFlipHandler(int fd, unsigned int sequence, unsigned int tv_sec, unsigned int tv_usec, void *user_data)
-{
-    Q_UNUSED(fd);
-    Q_UNUSED(sequence);
-    Q_UNUSED(tv_sec);
-    Q_UNUSED(tv_usec);
-
-    QEglFSKmsScreen *screen = static_cast<QEglFSKmsScreen *>(user_data);
-    screen->flipFinished();
-}
-
 QEglFSKmsGbmDevice::QEglFSKmsGbmDevice(QKmsScreenConfig *screenConfig, const QString &path)
     : QEglFSKmsDevice(screenConfig, path)
-    , m_gbm_device(Q_NULLPTR)
-    , m_globalCursor(Q_NULLPTR)
+    , m_gbm_device(nullptr)
+    , m_globalCursor(nullptr)
 {
 }
 
 bool QEglFSKmsGbmDevice::open()
 {
     Q_ASSERT(fd() == -1);
-    Q_ASSERT(m_gbm_device == Q_NULLPTR);
+    Q_ASSERT(m_gbm_device == nullptr);
 
     int fd = qt_safe_open(devicePath().toLocal8Bit().constData(), O_RDWR | O_CLOEXEC);
     if (fd == -1) {
@@ -103,7 +92,7 @@ void QEglFSKmsGbmDevice::close()
 
     if (m_gbm_device) {
         gbm_device_destroy(m_gbm_device);
-        m_gbm_device = Q_NULLPTR;
+        m_gbm_device = nullptr;
     }
 
     if (fd() != -1) {
@@ -134,24 +123,13 @@ void QEglFSKmsGbmDevice::destroyGlobalCursor()
     if (m_globalCursor) {
         qCDebug(qLcEglfsKmsDebug, "Destroying global GBM mouse cursor");
         delete m_globalCursor;
-        m_globalCursor = Q_NULLPTR;
+        m_globalCursor = nullptr;
     }
 }
 
-void QEglFSKmsGbmDevice::handleDrmEvent()
-{
-    drmEventContext drmEvent;
-    memset(&drmEvent, 0, sizeof(drmEvent));
-    drmEvent.version = 2;
-    drmEvent.vblank_handler = nullptr;
-    drmEvent.page_flip_handler = pageFlipHandler;
-
-    drmHandleEvent(fd(), &drmEvent);
-}
-
 QPlatformScreen *QEglFSKmsGbmDevice::createScreen(const QKmsOutput &output)
 {
-    QEglFSKmsGbmScreen *screen = new QEglFSKmsGbmScreen(this, output);
+    QEglFSKmsGbmScreen *screen = new QEglFSKmsGbmScreen(this, output, false);
 
     if (!m_globalCursor && screenConfig()->hwCursor()) {
         qCDebug(qLcEglfsKmsDebug, "Creating new global GBM mouse cursor");
@@ -161,4 +139,20 @@ QPlatformScreen *QEglFSKmsGbmDevice::createScreen(const QKmsOutput &output)
     return screen;
 }
 
+QPlatformScreen *QEglFSKmsGbmDevice::createHeadlessScreen()
+{
+    return new QEglFSKmsGbmScreen(this, QKmsOutput(), true);
+}
+
+void QEglFSKmsGbmDevice::registerScreenCloning(QPlatformScreen *screen,
+                                               QPlatformScreen *screenThisScreenClones,
+                                               const QVector<QPlatformScreen *> &screensCloningThisScreen)
+{
+    if (!screenThisScreenClones && screensCloningThisScreen.isEmpty())
+        return;
+
+    QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen);
+    gbmScreen->initCloning(screenThisScreenClones, screensCloningThisScreen);
+}
+
 QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h
index 08ca28d48e..518e2ce58b 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmdevice.h
@@ -65,9 +65,11 @@ public:
     QPlatformCursor *globalCursor() const;
     void destroyGlobalCursor();
 
-    void handleDrmEvent();
-
     QPlatformScreen *createScreen(const QKmsOutput &output) override;
+    QPlatformScreen *createHeadlessScreen() override;
+    void registerScreenCloning(QPlatformScreen *screen,
+                               QPlatformScreen *screenThisScreenClones,
+                               const QVector<QPlatformScreen *> &screensCloningThisScreen) override;
 
 private:
     Q_DISABLE_COPY(QEglFSKmsGbmDevice)
@@ -75,12 +77,6 @@ private:
     gbm_device *m_gbm_device;
 
     QEglFSKmsGbmCursor *m_globalCursor;
-
-    static void pageFlipHandler(int fd,
-                                unsigned int sequence,
-                                unsigned int tv_sec,
-                                unsigned int tv_usec,
-                                void *user_data);
 };
 
 QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
index 058791e473..402338197d 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmintegration.cpp
@@ -43,21 +43,13 @@
 #include "qeglfskmsgbmdevice.h"
 #include "qeglfskmsgbmscreen.h"
 #include "qeglfskmsgbmcursor.h"
-#include "private/qeglfswindow_p.h"
+#include "qeglfskmsgbmwindow.h"
 #include "private/qeglfscursor_p.h"
 
-#include <QtDeviceDiscoverySupport/private/qdevicediscovery_p.h>
-#include <QtEglSupport/private/qeglconvenience_p.h>
 #include <QtCore/QLoggingCategory>
-#include <QtCore/QJsonDocument>
-#include <QtCore/QJsonObject>
-#include <QtCore/QJsonArray>
-#include <QtGui/qpa/qplatformwindow.h>
-#include <QtGui/qpa/qplatformcursor.h>
 #include <QtGui/QScreen>
+#include <QtDeviceDiscoverySupport/private/qdevicediscovery_p.h>
 
-#include <xf86drm.h>
-#include <xf86drmMode.h>
 #include <gbm.h>
 
 QT_BEGIN_NAMESPACE
@@ -105,7 +97,6 @@ EGLNativeWindowType QEglFSKmsGbmIntegration::createNativeOffscreenWindow(const Q
     Q_UNUSED(format);
     Q_ASSERT(device());
 
-    qCDebug(qLcEglfsKmsDebug) << "Creating native off screen window";
     gbm_surface *surface = gbm_surface_create(static_cast<QEglFSKmsGbmDevice *>(device())->gbmDevice(),
                                               1, 1,
                                               GBM_FORMAT_XRGB8888,
@@ -134,8 +125,7 @@ QPlatformCursor *QEglFSKmsGbmIntegration::createCursor(QPlatformScreen *screen)
 void QEglFSKmsGbmIntegration::presentBuffer(QPlatformSurface *surface)
 {
     QWindow *window = static_cast<QWindow *>(surface->surface());
-    QEglFSKmsScreen *screen = static_cast<QEglFSKmsScreen *>(window->screen()->handle());
-
+    QEglFSKmsGbmScreen *screen = static_cast<QEglFSKmsGbmScreen *>(window->screen()->handle());
     screen->flip();
 }
 
@@ -160,46 +150,6 @@ QKmsDevice *QEglFSKmsGbmIntegration::createDevice()
     return new QEglFSKmsGbmDevice(screenConfig(), path);
 }
 
-class QEglFSKmsGbmWindow : public QEglFSWindow
-{
-public:
-    QEglFSKmsGbmWindow(QWindow *w, const QEglFSKmsGbmIntegration *integration)
-        : QEglFSWindow(w)
-        , m_integration(integration)
-    {}
-    void resetSurface() override;
-    const QEglFSKmsGbmIntegration *m_integration;
-};
-
-void QEglFSKmsGbmWindow::resetSurface()
-{
-    QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen());
-    if (gbmScreen->surface()) {
-        qWarning("Only single window per screen supported!");
-        return;
-    }
-
-    EGLDisplay display = gbmScreen->display();
-    QSurfaceFormat platformFormat = m_integration->surfaceFormatFor(window()->requestedFormat());
-    m_config = QEglFSDeviceIntegration::chooseConfig(display, platformFormat);
-    m_format = q_glFormatFromConfig(display, m_config, platformFormat);
-    m_window = reinterpret_cast<EGLNativeWindowType>(gbmScreen->createSurface());
-
-    PFNEGLCREATEPLATFORMWINDOWSURFACEEXTPROC createPlatformWindowSurface = nullptr;
-    const char *extensions = eglQueryString(EGL_NO_DISPLAY, EGL_EXTENSIONS);
-    if (extensions && (strstr(extensions, "EGL_KHR_platform_gbm") || strstr(extensions, "EGL_MESA_platform_gbm"))) {
-        createPlatformWindowSurface = reinterpret_cast<PFNEGLCREATEPLATFORMWINDOWSURFACEEXTPROC>(
-            eglGetProcAddress("eglCreatePlatformWindowSurfaceEXT"));
-    }
-
-    if (createPlatformWindowSurface) {
-        m_surface = createPlatformWindowSurface(display, m_config, reinterpret_cast<void *>(m_window), nullptr);
-    } else {
-        qCDebug(qLcEglfsKmsDebug, "No eglCreatePlatformWindowSurface for GBM, falling back to eglCreateWindowSurface");
-        m_surface = eglCreateWindowSurface(display, m_config, m_window, nullptr);
-    }
-}
-
 QEglFSWindow *QEglFSKmsGbmIntegration::createWindow(QWindow *window) const
 {
     return new QEglFSKmsGbmWindow(window, this);
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmwindow.cpp b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmwindow.cpp
new file mode 100644
index 0000000000..110a592dec
--- /dev/null
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmwindow.cpp
@@ -0,0 +1,80 @@
+/****************************************************************************
+**
+** Copyright (C) 2017 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qeglfskmsgbmwindow.h"
+#include "qeglfskmsgbmintegration.h"
+#include "qeglfskmsgbmscreen.h"
+
+#include <QtEglSupport/private/qeglconvenience_p.h>
+
+QT_BEGIN_NAMESPACE
+
+void QEglFSKmsGbmWindow::resetSurface()
+{
+    QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen());
+    EGLDisplay display = gbmScreen->display();
+    QSurfaceFormat platformFormat = m_integration->surfaceFormatFor(window()->requestedFormat());
+    m_config = QEglFSDeviceIntegration::chooseConfig(display, platformFormat);
+    m_format = q_glFormatFromConfig(display, m_config, platformFormat);
+    // One fullscreen window per screen -> the native window is simply the gbm_surface the screen created.
+    m_window = reinterpret_cast<EGLNativeWindowType>(gbmScreen->createSurface());
+
+    PFNEGLCREATEPLATFORMWINDOWSURFACEEXTPROC createPlatformWindowSurface = nullptr;
+    const char *extensions = eglQueryString(EGL_NO_DISPLAY, EGL_EXTENSIONS);
+    if (extensions && (strstr(extensions, "EGL_KHR_platform_gbm") || strstr(extensions, "EGL_MESA_platform_gbm"))) {
+        createPlatformWindowSurface = reinterpret_cast<PFNEGLCREATEPLATFORMWINDOWSURFACEEXTPROC>(
+            eglGetProcAddress("eglCreatePlatformWindowSurfaceEXT"));
+    }
+
+    if (createPlatformWindowSurface) {
+        m_surface = createPlatformWindowSurface(display, m_config, reinterpret_cast<void *>(m_window), nullptr);
+    } else {
+        qCDebug(qLcEglfsKmsDebug, "No eglCreatePlatformWindowSurface for GBM, falling back to eglCreateWindowSurface");
+        m_surface = eglCreateWindowSurface(display, m_config, m_window, nullptr);
+    }
+}
+
+void QEglFSKmsGbmWindow::invalidateSurface()
+{
+    QEglFSKmsGbmScreen *gbmScreen = static_cast<QEglFSKmsGbmScreen *>(screen());
+    QEglFSWindow::invalidateSurface();
+    gbmScreen->resetSurface();
+}
+
+QT_END_NAMESPACE
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmwindow.h b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmwindow.h
new file mode 100644
index 0000000000..a19cf7e8bc
--- /dev/null
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/qeglfskmsgbmwindow.h
@@ -0,0 +1,67 @@
+/****************************************************************************
+**
+** Copyright (C) 2015 Pier Luigi Fiorini <pierluigi.fiorini@gmail.com>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Copyright (C) 2016 Pelagicore AG
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QEGLFSKMSGBMWINDOW_H
+#define QEGLFSKMSGBMWINDOW_H
+
+#include "private/qeglfswindow_p.h"
+
+QT_BEGIN_NAMESPACE
+
+class QEglFSKmsGbmIntegration;
+
+class QEglFSKmsGbmWindow : public QEglFSWindow
+{
+public:
+    QEglFSKmsGbmWindow(QWindow *w, const QEglFSKmsGbmIntegration *integration)
+        : QEglFSWindow(w),
+          m_integration(integration)
+    { }
+    void resetSurface() override;
+    void invalidateSurface() override;
+
+private:
+    const QEglFSKmsGbmIntegration *m_integration;
+};
+
+QT_END_NAMESPACE
+
+#endif // QEGLFSKMSGBMWINDOW_H
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_egldevice/qeglfskmsegldeviceintegration.cpp b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_egldevice/qeglfskmsegldeviceintegration.cpp
index 3af21d768e..a67457a6a5 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_egldevice/qeglfskmsegldeviceintegration.cpp
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms_egldevice/qeglfskmsegldeviceintegration.cpp
@@ -51,7 +51,7 @@ QT_BEGIN_NAMESPACE
 
 QEglFSKmsEglDeviceIntegration::QEglFSKmsEglDeviceIntegration()
     : m_egl_device(EGL_NO_DEVICE_EXT)
-    , m_funcs(Q_NULLPTR)
+    , m_funcs(nullptr)
 {
     qCDebug(qLcEglfsKmsDebug, "New DRM/KMS on EGLDevice integration created");
 }
@@ -75,7 +75,7 @@ EGLDisplay QEglFSKmsEglDeviceIntegration::createDisplay(EGLNativeDisplayType nat
     EGLDisplay display;
 
     if (m_funcs->has_egl_platform_device) {
-        display = m_funcs->get_platform_display(EGL_PLATFORM_DEVICE_EXT, nativeDisplay, Q_NULLPTR);
+        display = m_funcs->get_platform_display(EGL_PLATFORM_DEVICE_EXT, nativeDisplay, nullptr);
     } else {
         qWarning("EGL_EXT_platform_device not available, falling back to legacy path!");
         display = eglGetDisplay(nativeDisplay);
@@ -162,7 +162,7 @@ void QEglFSKmsEglDeviceWindow::resetSurface()
         qCDebug(qLcEglfsKmsDebug, "Could not query number of EGLStream FIFO frames");
     }
 
-    if (!m_integration->m_funcs->get_output_layers(display, Q_NULLPTR, Q_NULLPTR, 0, &count) || count == 0) {
+    if (!m_integration->m_funcs->get_output_layers(display, nullptr, nullptr, 0, &count) || count == 0) {
         qWarning("No output layers found");
         return;
     }
@@ -172,7 +172,7 @@ void QEglFSKmsEglDeviceWindow::resetSurface()
     QVector<EGLOutputLayerEXT> layers;
     layers.resize(count);
     EGLint actualCount;
-    if (!m_integration->m_funcs->get_output_layers(display, Q_NULLPTR, layers.data(), count, &actualCount)) {
+    if (!m_integration->m_funcs->get_output_layers(display, nullptr, layers.data(), count, &actualCount)) {
         qWarning("Failed to get layers");
         return;
     }
@@ -180,7 +180,7 @@ void QEglFSKmsEglDeviceWindow::resetSurface()
     QEglFSKmsEglDeviceScreen *cur_screen = static_cast<QEglFSKmsEglDeviceScreen *>(screen());
     Q_ASSERT(cur_screen);
     QKmsOutput &output(cur_screen->output());
-    const uint32_t wantedId = !output.wants_plane ? output.crtc_id : output.plane_id;
+    const uint32_t wantedId = !output.wants_forced_plane ? output.crtc_id : output.forced_plane_id;
     qCDebug(qLcEglfsKmsDebug, "Searching for id: %d", wantedId);
 
     EGLOutputLayerEXT layer = EGL_NO_OUTPUT_LAYER_EXT;
diff --git a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/eglfs_kms.pro b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/eglfs_kms.pro
index 27c0af1f08..43170a3875 100644
--- a/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/eglfs_kms.pro
+++ b/qtbase/src/plugins/platforms/eglfs/deviceintegration/eglfs_kms/eglfs_kms.pro
@@ -19,11 +19,13 @@ SOURCES += $$PWD/qeglfskmsgbmmain.cpp \
            $$PWD/qeglfskmsgbmintegration.cpp \
            $$PWD/qeglfskmsgbmdevice.cpp \
            $$PWD/qeglfskmsgbmscreen.cpp \
-           $$PWD/qeglfskmsgbmcursor.cpp
+           $$PWD/qeglfskmsgbmcursor.cpp \
+           $$PWD/qeglfskmsgbmwindow.cpp
 
 HEADERS += $$PWD/qeglfskmsgbmintegration.h \
            $$PWD/qeglfskmsgbmdevice.h \
            $$PWD/qeglfskmsgbmscreen.h \
-           $$PWD/qeglfskmsgbmcursor.h
+           $$PWD/qeglfskmsgbmcursor.h \
+           $$PWD/qeglfskmsgbmwindow.h
 
 OTHER_FILES += $$PWD/eglfs_kms.json
diff --git a/qtbase/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp b/qtbase/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp
index 9a0be489a8..33878a5f50 100644
--- a/qtbase/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp
+++ b/qtbase/src/plugins/platforms/eglfs/api/qeglfsintegration.cpp
@@ -324,13 +324,14 @@ void *QEglFSIntegration::nativeResourceForIntegration(const QByteArray &resource
         result = qt_egl_device_integration()->wlDisplay();
         break;
     default:
+        result = qt_egl_device_integration()->nativeResourceForIntegration(resource);
         break;
     }
 
     return result;
 }
 
-void *QEglFSIntegration::nativeResourceForScreen(const QByteArray &resource, QScreen *)
+void *QEglFSIntegration::nativeResourceForScreen(const QByteArray &resource, QScreen *screen)
 {
     void *result = 0;
 
@@ -341,6 +342,7 @@ void *QEglFSIntegration::nativeResourceForScreen(const QByteArray &resource, QSc
         result = reinterpret_cast<void*>(nativeDisplay());
         break;
     default:
+        result = qt_egl_device_integration()->nativeResourceForScreen(resource, screen);
         break;
     }
 
@@ -427,11 +429,9 @@ QFunctionPointer QEglFSIntegration::platformFunction(const QByteArray &function)
 #if QT_CONFIG(evdev)
     if (function == QEglFSFunctions::loadKeymapTypeIdentifier())
         return QFunctionPointer(loadKeymapStatic);
-#else
-    Q_UNUSED(function)
 #endif
 
-    return 0;
+    return qt_egl_device_integration()->platformFunction(function);
 }
 
 void QEglFSIntegration::loadKeymapStatic(const QString &filename)
